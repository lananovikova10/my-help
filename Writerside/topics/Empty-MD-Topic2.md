# Creating Strategies with TSAPI

TSAPI is a powerful library for developing and simulating trading strategies. This guide will walk you through the basics of creating strategies, using key features of the library, and writing efficient code.

## Overview

[//]: # (TODO: fix this)

TSAPI allows you to define trading strategies, simulate them on historical data, and eventually go live with 
real-time data. The core components of a strategy include defining the instruments, scheduling, event handlers, and 
utilizing SAXXXX for time series analysis.

## Key Components

### 1. Strategy Initialization

Initialize your strategy by setting up the instruments and scheduling.

<code-block lang="c++">
<![CDATA[
#include "tsapi/tsapi.h"

using namespace tsa;

class my_strategy : public tsa::strategy

{

    void on_init() final

    {

        // Initialize instruments and schedule

        instrument sp500;

        sp500.open_table("sp500.daily");

        auto_schedule(std::chrono::days(1));

    }

};
]]>
</code-block>

<note><p>The <code>on_init()</code> function is crucial for setting up the initial state of your strategy, including connecting to the appropriate data tables and setting the schedule.</p></note>

### 2. Handling Events

Handle various events such as bar close, transactions, and orders within your strategy.

<code-block lang="c++">
<![CDATA[
void on_bar_close() final

{

    // Code to handle bar close event

    println("bar:", bar_count(), "Timestamp:", bar_timestamp());

    // Example condition to exit strategy

    if (bar_count() == 10)

    {

        quit();

    }

}

void on_transaction(const transaction& t) final

{

    // Code to handle transactions

    println("Transaction at:", t.timestamp(), "Quantity:", t.quantity());

}
]]>
</code-block>

<warning><p>Always ensure that your event handlers are efficient and do not introduce unnecessary delays. The <code>quit()</code> function is used to gracefully terminate the strategy after the current bar is processed.</p></warning>

### 3. Utilizing SAX for Time Series Analysis

SAX simplifies time series analysis within strategies. Define your analytic expressions in the <code>on_SAX()</code> method.

<code-block lang="c++">

void on_SAX() final

{

    auto sma_short = SMA(sp500.CLOSE(), 10);

    auto sma_long = SMA(sp500.CLOSE(), 50);

    // Generate buy/sell signals

    VAR(buy_signal) = sma_short.CROSSES_ABOVE(sma_long);

    VAR(sell_signal) = sma_short.CROSSES_BELOW(sma_long);

}

</code-block>

<note><p>SAX functions like <code>SMA()</code> and <code>CROSSES_ABOVE()</code> are used to create sophisticated time series analyses easily.</p></note>

### 4. Creating Orders

Create and manage orders based on signals generated by your strategy.

<code-block lang="c++">

void on_bar_close() final

{

    if (sp500.is_flat() && buy_signal)

    {

        sp500.buy(100).at_market().as("BuyOrder");

    }

    else if (sp500.is_long() && sell_signal)

    {

        sp500.sell(sp500.position_size()).at_market().as("SellOrder");

    }

}

</code-block>

## Example Strategy

Here is a complete example of a moving average crossover strategy.

<code-block lang="c++">

#include "tsapi/tsapi.h"

using namespace tsa;

class moving_average_strategy : public tsa::strategy

{

    instrument sp500;

    void on_init() final

    {

        sp500.open_table("sp500.daily");

        auto_schedule(std::chrono::days(1));

    }

    void on_SAX() final

    {

        auto sma_short = SMA(sp500.CLOSE(), 10);

        auto sma_long = SMA(sp500.CLOSE(), 50);

        VAR(buy_signal) = sma_short.CROSSES_ABOVE(sma_long);

        VAR(sell_signal) = sma_short.CROSSES_BELOW(sma_long);

    }

    void on_bar_close() final

    {

        if (sp500.is_flat() && buy_signal)

        {

            sp500.buy(100).at_market().as("BuyOrder");

        }

        else if (sp500.is_long() && sell_signal)

        {

            sp500.sell(sp500.position_size()).at_market().as("SellOrder");

        }

    }

    void on_transaction(const transaction& t) final

    {

        println("Transaction at:", t.timestamp(), "Quantity:", t.quantity());

    }

};

try

{

    moving_average_strategy s;

    s.run(date_time(2010, month::jan, 1), date_time(2020, month::jan, 1));

}

catch (const std::exception& e)

{

    println("Error:", e.what());

}

</code-block>
